<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb3cf9c0f589aa18293a9e7ef3b1551f0da6a31eaeeba91dc75d0211356771841b2006cab81d80f4d9a6044a686be0f460b037f96b71dd0dbe41aa26e9e66ee87475e561bc1742aa73abb88c525352ca4ee3db13a26cd070503f526ecc60814037b3e931f7292ced419f89db4fcacc32ffadc0e6b1f60f2f9c91f4db65049f6eaf1dcb460e64fc2f27302bfd7e47d890369e14fa2b61f3dba59a66540d8142339d6840e10e75a2f0bba0214dd92c11464ee5b91e1ba237b056e025ab5012ec753eabfbef3bad9424b85d7d49efff01600eb4ac76e751fe20936699989fec00d57ae863091f7c34892018a3a559adab90bc4ad7786e191dc083a3e4a0681ada45f7248c58a03244f485a9a43ae1378f3361fa02ce853e08d0b0c4b917721364831333c2cfcade21bca0dcb4280acce7ded348bd05b20d274417063626133bb876e15fb17a35a07b87b6b53357adc850d8bd3eb4041a2e04073117429328e9a5eb74bca0a7ceea78245255c33ca168eb16a7dc39e08f3e2be029d712c8df2d32d40eec584862252841a9023365ea5b7fe2206f14274fca886785b91934e8fa45e71de410afb32dce2ec6c699ee9a506c4b3e8748e18af9a83dd057e49114049545c7d91e0590dc9bf06641c04d4612bdfd841d186c835b43475ef4ef2923321c7d6251b709d89c01c45d08e82ac892446d1a4af7c8d05a3ef8374b45e2c853083dbe24d0d27f9d87abc147f9fe6cda7c460a4016a4e4b830e0f260b50abb9ef31bdb43208af1e0ffcdc587a9d5e11aa04da350817e648131188db93533498e76794ceda8c2525fd5c87374ba4e544693d0ce7d69fc29f519bde4f7d666c67cedafe14c388eb6f5d65a345e075b47ca8352530962d37893570450f23742538ab124bba6d5ffccaa2ee45df859c7c575266570e4534302956b11e1b511af0e3e9dc97d8dac96f2f4a3f7fd91e64be60b03241dca0a2a0c9b9e46dc15af1d7e7629d9ed1fdb78ff142d2001d21e63dfa6e1e5f1f5239dcb7ed1b14be0c0a436140d699e39c1b6833db1205a9f6db69825fa1cc861e5672890696d093a69add6b4fd930bad120a84d94bb46e0c116979ac426c4c240bf33361aa383685c13f61788ad470d5dc581dbdc9d4634887a3f4a36418d2dc557d50ec2beed3cbe939fdb979c096269b04bd56226db7a35560515aaaf6fbec1ddfdf6a429b15d4f6764f03b823853bf30447fb66b89950b569eb8a9ea67b7b592b5443c37b71e08a44a00c2465675104d7e4ff931662d010a2aa687e8a3a3d539ae79ad2f5a31dc8c5ebfa5c3ac726df10847facebe6d71a200d0cce84279af620cd1cd4a7baf240d06353bbdef08ab7692b3f5190c583c266ccc5ec95e68f406072ff5c30592799d40b1e2701a30e83dfe291c25a9a82c44be8a4654a6088d049cd5cc29e92c54fdd596fa98ba61b009ce80aff07e940297b3c4b241387080eea9a30f3fbc99e29585ca6cef22038f9c1a94bf05b59fef3ed903cd16ae49d0232766485fe19523bb6a9975673e9a63bcb0fa3b985a1d8adb76867b0e052847ec02be637ab78a82b7c9b2492622ef00a22236a41de2cf50becf98af5b7590d2d7a700c299b567dca34c309a2298ff9aeb75a1de61233f78f477cab039a44caae26f6be7f77f869fb924cbb39e331f8c8b0e733b483a21447aafe9f02b1fdd28d8fbc45bf8cd34c97f331fa06d2706bde9e4ee77517cb35a492e58766cfff0bbf97c7db75ab8ef4a46fb3c245cac91c04469df38975f41ca614114d5b7da787bc176625e3a9d02f0e8a324ec27d8c2dc02d88943d1c5a9d0962823fefdf9b67f830aa4ba3e052c04613c4ceee0572611e4a129e42588dfe4634a91c53b5cda2889df6e20801bc214ad277e425fe7bc9afcbc55e81fe20b4bbaa1528e074593581fd7ef77b40f353dedd5afd2733504a8cda13009e7886f8bcd0f88018f8023c1d2fddf49accc51fafe78b81982dfe2816cb0d82f68b265b755eaa96c29b823840ff178c6d36744d5bd4f6529c6bd3917f1a1636a0db2a59145465f6f91dc65494899dfd9b33d39967e132ad4d32f012429f759d085782d35d54e60b0e5c2cc7bb2a9640ac08e00b0eedcd357619ea36f4883598bce93b07a326159a08cd36a31a6abfc4796faf074002c262eea3a661f5eddd63c9d810c78ab01b5f4e8e7d1e43096d2b661d136130cb2684a2b1c60b1fa3bcf25f23a7acd3185a02bb8aab56a1626667f5a8deabb7320e79db4f3b6752d2e0e1eaea72fe071412fd0b8c2b606025998fd679cc6d01a4272515016e38786cc1fafae3de15725babd600f3cb8b04eecc30a732aaf01d2218d851e764168a9d6d025af31d21f089293bf5472b43067afad7b221284ed50e7082f6553c0569bb1a3047d6f046799c0d78f3efaf3ea0540b23250e61402969392299f2c9aae65aeac65e98ddaeb8be5e49191699e9e5d86a11c55d3d42050472f6d0f29ab5f73dae8504f3f457dee2821de40cad451fd8c800c1a490030d5c54c0602c41acfb5bce9ac6063d71f607549d7dada40454adfad2352bef11f8e0218f46540d0d6f0f2af76f2a08f762c0f07b4b69fbe8707f3d7d417adba9da7c4cd63b70b685515861e27c677fb3352ae4cb17ec05e8990417d35e52be5a610cfc38a030c6a306fe992a800019e4174a430ab6d2fbb1b0581aaf6b340bac4f5155e2dedfda3afe3b053d419910dac83602224dd3631c44ebc383a9a644259390da8426205c4a2badd7e8298b0cdf9e9a13bda4b912d7fe9d9eeda34aff21447c260af7ecab275369c9eb342577a5e939a97e345c59a5722e301c1b25720b326a20426a10a4ea63c310bc283d7e3d94abe90702843dcedccc9e1c26b71f366816ad368712599163169a98f0fad482953a2148df818a2f09c87b81a910bee8363192cc3deafed1cf65e31b28dfdbacef4dfa4cb5d95ac71418134a746898da5a05ef60f4a4a5a0e56382dfb0fe6e8abeed489b0ec60890f4df08393e40fbdaa34d8029031145d5781a70442a52660c78fe6c508f47a43dd2a062e711f8a2a0a6167418fa18756059e8c8d6f7d2179fd76fe77562cf422f356d1f8521dd512ff34ff77fda6c3ddfdec2f9a8b780c6dddc01e9cb7be19f7df2fee05d5f7a3a06c968dcf4ac71852dafc1c75e3c407d383c776eb3c13ef6def134a814f16a3298d64cb39ab461ba753d6d2d1884f2b462611f2fac3d23dcb451437efac716c43dfa1d8afd7a0fb045a2290176f7b775d0f273bad49fb1c6eb060d602303fe4bae570aa932777740913c49d60107bcdb6bd93b6bc280a58756efef095fc00f2a1b9da996f577db62fe976e0e3b83a71dcbcfad39c70b9f767fe22d8434f58812a17d53f0bc2d569d94804b418c758650dfc643b4b04b878cbaba8e8c902e4bbf46c726353fa549c16220fdfb851050d804b0db86aea120bf4639294a9c96a7c6b8f38a7e581be86924e1188ae3f08c60de1b396469a47e784ff95759510d7ff0c213d9390fa7128681e6399da444c7d678cc222687bf3f6d4718a52a45c79c746e2b9fbea519a4a10333f76cf0417042c1a472ab9d08b4bdcbc625097b66d9a4966a1256924ca659c54ac26e176fc93181f036109d286e6115544faf8b6c4baeef5dca88a42001907985e7de7c05533f9ba724ea870dabec5c27e9c838cb6b3bf3126c4dcc8124e265277ae5b430420491276dfb59adcede057c1840a6f3c1a43ea17a13c1bcc4e800a3a4f4ec221fa351fe1fb84df54f2af9fa7efd3720f6ba7c6fcc5ce1227714cfaa77725e286135065b7cdcbadffaa80a17d8834c1a699f12af33df5cc4ed190ff1a75c5589ddfcf5d46c830992114c719abc7abf5b1586925161ea42528d53201a32729bdc75854c61e7b284d721efddb6edadc12cd480ea30f2e9f280662dd94fe9a876eb852bbd468026389cdc56f611f4ae9828d4a2ec5d6294fd7794fa1b305d9bb0f95545cadd3c77a517d76f1d4a32d24c54977a18cde2a4b6c6b08fccbd597adad33204390a7b511866ffd8b44c1055019858f29fc0119486ba25576cfba4ffcbf6703be4f223fc984a8b709df1258cecad871e20464a6b5f6e1bf523c37fc929065ffba4297e8653f5e38231e60ce1f3ec9d5901b1120aa0138fbc9b7df1978484302474b1c8d229b50ef5600aa7a3cbc25e2f20d9bfa42a626dc2a9d5275b1c1d8c8dd773663a59f116229a9f10bb4cade0f01ac72e1d1cc96aedca9ca471ffceaba86fb370ceda49c1f5c5e62e574f21398e1eb5a3c470f127dff686976780e2c95483ed6801662a436fe14bbb2acbaec3c8affa7d782ae50f00fb3b8a47ed8d055a150b4e653293fd89b6923d2a9a5a8632f7901d17780dc3b7d53e0fd5b9de7c29924d5e238c7916307308b4ba600fc62579deaa9d11c548f7135646c0c13d7cec0b39f93e920ccc90ae3f638bf0d958fae6a2efa521b64303c486ff0d0d0e35bc0a6bc3ee5aeb973edcf2da02c17ab7c88552f5c56bd6525c8c7901bd59f4a1ce5902f06ba8e198db4c6ffc1eb3b6e4da683659c24ac1c71f1475bf522119601ec90d50df315dd1f85bfd24922aac40733a6e24e29af71d00c6453b014160ae098af6968ae41680b50cc19b19ff6d87abf0b6cc308657639e0c22950a82f459e55ede4cca0f2e1cf01994ade489cfb725240b91b35a335857da72513a09831cf61c104958150c1ec021f8200f4518e999196b1257c83cb12729284d68fd4c95e3583e545ee378750061e0aeeab794b9fa00401eb111278b29f4073bf599b7937d972a6a146845741d632446f577e9cf0080e91e237b3e8371d26a8f2f73c76960a1b413289b334e0ff39726ee36173b76462b0f3f0d51b9ffad09b6e0ccdedc3ca3621707267bf207338b437ddaec473ca289e8c041cf2251481b161dacdc138400be53d23fd7e2e6ec06d32d617db18c2fdc4702500fbdee3aa10aadee284d2e188e0065351136092c204583072cce0d4b2b9d2a646cee20c34297809910fd19a189e5338a1dbc90ec555a0438c2c1a813ec507e699d1a1da5eb35c2c7e0ad886e2dad9291137e7cb659d0be61cc13ccbceea2268388149c092904b60ea87e8f9d006ba7412b26aac1021c96f9cfb0ad95a802fc3d4eaed4ecde7b48c539ff4e9a67874be6c380c16221551d8f6cee48c3f188269f28099bad8650ae9fa9c923f0a5eb977cc54e81b6ab7344a61782d3bf29922d95cbde44d3d34b307bcec76b0534871ea65e253d238fc4519420dcce814057f00fe7ea6eeed45d0f5bd40210e67a4ca11ea7012d9dc389cb9ec48aa47a25ac7cef0061febae5bc0dab0e9809386d9716c9dd26c12a61a29a911d8a9c6e21b0eb0989239699cd8520b45a90520ae7fa0b970aa9a09f2f81bb5940cb50b05be21b24d9435ef5d5fc0a8963c9d9acd615dc89fefd8bd368f65964e664ed8c5e2ba10ac6733f31e159ae8f7a2474d0d306463a7c2d93c792dad8e386d77b0d637acadd47e9d9b35fb97882f912ef4fdfe93909694cdacf13a81dff1ef24a043c71006f247f5a286d972025397842eb633be2618a9d47008dcffbeb3bfc8f46d163ea69498121c11347a2168a8d53a6b71bd793f6e433b9ec8e4ab1d67d5177b1d50525578eefbe60ee5b607b0467ec18cfd98459cecd465bcbac34dc5c40fcee802e7a03b503d1139d94b88de49d85d68206bb65f11112b0ba609a476d54608dea54e4fa6e14d7b7f59b27436dc967661372ebebd87e296a799084431733c3aa72b60754048fbe73e1dfcf270d8d71cdb637afc0bf835a9f548f386e673219ce0193c4012d431efe70a15ad4555be31f7fdf99a36b6e08ef345aac0663ccf9d312110bc3cdc89e160e61d53432e0349159fd0bcda790ce5ccf6aa08d202277a20ee2ad0c76753cfa241c2d507ab113bd6e575326b77f8c45406119bf603e8d5dadcb89acd7b99e1330c3c86fdefefe446e372664bd3d0ebc576516978e438b4b6ba702a6eea50ecee6f8d1d8dd614d4b6540eba39af600a8e3b683508f3f18454753fedcc32af2bf830cdcc8d4ef02cdee379bc3b419754414d09a00b331a373dd010eab68f7edbf6d7989ab7efa2ba05b6e3ea7ea9b9e690c44eafc84260dfe8e55bb89eb716a42df5948c795e0aba1c26ab746e40a8ede3d01397e12a3614c5896c1a78307d1d737c825e7d887e6ab35e2ffd674865fb28a719e951209a11156d6ffcc8e8d1e5e819d1bb920454e3ba89826e974d00d451e3dd0d74b9d1e323f3618c9e7eb410e137ef5fcebb4ae4e2d3628959e325b08526bf0173f95155acea0091d9ad078678a387c45b9041dc16aae81cd0bd3b59e5d4fbaa88892f1f9be324a562978fca1bc6137737e9f69d6306c5c454c1ce46255eebb9bf54f7dd210d8502f159442e5448a079d0b699270ca4384d66e8a2d0dbf47cc90ffaf27cd4bfbc727e69023cb8ff702353ce07f627d766bf916acf69affd72bd56453bd0f2fc2339d0b885f8c46edff0d6bed95a1aca1f87f412a1ae4897d98e0cb1d21a46650388ae06ed26afd4800b47a29cec5bd51c3d0a920d6b34bc55ba2114d676426ca3af10cf79e1d904d5c7eacf8c1813aa1128dbe628387cca49fea9df208013d9c75dab81af5b813af6fda14ae8630bd7ee262dd874c5fa2826eb7acdce3fcbeb896095b9a5e35d8f2aa7825507d9681bdafe770b7771084fd25c49f2b6d38b719c923cf1e5712ae52d0cb1319289147638f86463a9a8e85c55cd152a0a2aeeb4b15135381ddd0e2aaf436331825aa509e5f148c037f827fa83b43e3ab97798b2806baf874d880baf4ebb4f4a5356198d797d16e81b32de5e469978912df9637e8c14c8a983658a5d34be0816cf611227750fca8d3bf3739980e2712ca6bbe05e1d5f349418a7aac4cfe6a9c483ae3dca93f0a6639a2904a1442575e1f9ba2645bf7e98a502eb954f7d96f02eea1a42116401f796e8e23870466718330a19a89832705ca4432187790bed1fb3a225c991c869f40d5337bc10553a9d13352f01ad4e2245c68aefad6298b7d72f2c8354b31650b6b5eeb6e967a065cb5d9190240b47aac30eef26f73a5be13caa1f89578e6eeec1e71d3c0515966f756787a2c7f5e116e3b271b0094079d4a5726e895289c813539828aa6ccb454fcd44cd481a40170c806ccd2d65d4989cb8a44e0dc12f4d6205d8e985718e1904362d858b685ea1382344efb478afe90d3dc9984baffcb6d663782ad84f718570674e20ae43a677fd3817ed80a9d3744208bd966139d4cfec9c667fd275c57b3b48bf1343738bd5183ef45a7cc8d785ebc3c18b8257536fc609b3b5bc92a2d5c5300df935fe3f221805e43e8538b38538eb0c46c80ab4721480db7361c490cdf471a9f21accfdbf0282b90f713c1a214d69abec8b42123cfc4a4ea5ccd4db8b6aa7095e5ed94d6b893f1977941d36bd9dffe88caac35d17bd881ad6db30f318fb46eb79fbbbded6931d6f3520679436522b63c9327b850d904f564dc5c0cb64a0bf55c285a4e832d458b6514af63dacbcb6844192d36e6a2b2986aefd37290b7ab88f7b371247fff5c95fa04eafc58e0fc63d190c56ca27d82e03319ff69adc6db952496973d9ffe093ba78c9993abba729dfffeb87335b3d0c2eac727de6b838267f3a23bdd566e76dbccfd2de64bc7129c2d90a736c86326dd328f091c557624d77b2a9b7062eb997e499e91e7430ef13bcb4d4eb589c7fd5447eab928de81cd28159ef5eccdfb826145ce5efdf44fc43c6d096af3983d4a24ac90528db2325ca3bd0d3d478b1fcf04435ddc7c625af72c7aeb09a16093f98da52ecd166e201945d2edf13810e47b7800e1688305d35d806e72a5d83e55f3425b42fb7bfc8f1edf62298164b10a3c11b17564624902e99384f2373a27081866b4750dbe059bc2d4f098c60ab9300961297e30cb3bac887cdb86794cf81c1798f1817a993c935e8e5a645535204a2389f7e6e7a0160a75d536e6e40e324ae0a8651970890073f53648a48f981261f887dbbf84f47eb3f7f76db4b1c1998535b9a319c2a09c097d02b5a7a1668b219b757fab13dfb9545c72b895f9eff8b4d9d25db5f8d8779eb5ea53be7621039a02fdddbbfdcde39b217352a5028c9b48d9bdc1aefa9e811cb3abc8f60d9555c691348556d0aff14327630659f1159aae2a1a3ba2e3f497d2b51f372cd22c16923b8d345fc196261ea5e010aab3f37f6301846d3229e80ff9e38f71a7ac183990892a52a4e390758a175682c817def0f458d217b3bad6715972987bbe9465ce218db730f136c9fe8f4c14bf29e6ffd0dc789c7256ce25499b5fb17c3a5ce236efafcd262e87e19b804ed59a2d324624cb75ca8fcebc73c1829c7423bd3c181e1b98a22b4e982c10dc7f461ff3d718e71937cd4b7a39723e3fdc5fa663825093afc48ce73ffe2b66722a839a2f461910d9d49f6c3acc49b18fa0e8310784ac4aba0ea16a6c297081dc836bf3b3ebfeaca81344ef6820c86f89c43823b573a56fb34f2e5302eaa94d8ed8729d157554a716947004914c12fa31fe69c6f10a89e9137ec977f297f2f7da5f0f57db5651c51c20054a9f7a5c4071031c08a1b7af3af92654a51bb4baf7e3b893580e8e022f277fe65bace89f91736d71a827d7225a5d5cd848eaf89dbb151139a289029953456eb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c420ce757ad2dfe166392890ea8055bb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
